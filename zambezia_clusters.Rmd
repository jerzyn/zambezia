---
title: Real-time monitoring of Zambezia data collection
author: Joe Brew, Charfudin Sacoor, Carlos Chaccour, Francisco Saute
fig_height: 2.6
fig_width: 4
output:
  html_document:
    toc: true
    toc_float: true
    theme: yeti
---

```{r, echo = FALSE, warning = FALSE, message = FALSE, comment = NA, error= FALSE, cache = FALSE}
# No scientific notation
options(scipen=999)

# Packages 
library(xtable)
library(knitr)
library(ggplot2) 
# library(dplyr)
library(rgeos)
library(RColorBrewer)
library(Rmisc)
# Libraries
library(rgdal)
library(raster)
library(sp)
library(leaflet)
library(ggmap)
library(readxl)

# Basic knitr options
opts_chunk$set(comment = NA, 
               echo = FALSE, 
               warning = FALSE, 
               message = FALSE, 
               error = TRUE, # Render report, even with errors
               cache = F)

```

```{r setup, include=FALSE, echo = FALSE}
library(knitr)
knit_engines$set(asis = function(options) {
  if (options$echo && options$eval) knit_child(text = options$code)
})
```


```{r}
#### READ IN AND CLEAN UP DATA

# Source script
source('lib/get_zambezia.R')

# # Read in zambezia data from odk database
# get_zambezia(get_fresh = FALSE, save = FALSE)
# # Get a more nicely named core census file
# census <- CENSUS_MOPEIA_CORE

# Read in final spreadsheet, as provided by Orvalho
census <- read_excel('dropbox/final_joe_dataset.xlsx')
census <- data.frame(census)

# Get more nicely named geographic coordinate column names
census$lat <- census$y <- census$latitude <- census$gpc_lat
census$lon <- census$lng <- census$longitude <-census$x <- census$gpc_lng

# Get a shapefile for Mozambique
moz <- raster::getData('GADM', country = 'MOZ', level = 3)
moz2 <- raster::getData('GADM', country = 'MOZ', level = 2)

# Create a spatial version of census
census_spatial <- census
coordinates(census_spatial) <- ~x+y
proj4string(census_spatial) <- proj4string(moz)

# Subset the shapefile just to Zambezia
zam <- moz[moz@data$NAME_1 == 'Zambezia',]

# Subset further to just Mopeia
mop <- moz2[moz2@data$NAME_2 == 'Mopeia',]

# Save the original proj4string
original_proj4string <- proj4string(moz)

# Prepare ggmap-compatible objects
zam_fortified <- fortify(zam, id = ID_3)
mop_fortified <- fortify(mop, id = ID_3)
zam_gg <- get_map(location = c(lon = mean(census$lon, na.rm = TRUE),
                               lat = mean(census$lat, na.rm = TRUE)),
                  maptype = 'satellite')
mop_gg <- get_map(location = c(lon = mean(census$lon, na.rm = TRUE),
                               lat = mean(census$lat, na.rm = TRUE)),
                  maptype = 'satellite')

# Switch to a projected format
# Project
census_spatial <- spTransform(census_spatial, CRS( "+init=epsg:3347" ) )
mop <- spTransform(mop, CRS("+init=epsg:3347"))
# Later, we can switch back to lat/long:
# census_spatial <- spTransform(census_spatial, CRS("+init=epsg:4326"))
```

# Introduction

This document provides a basic overview of two different geospatial issues related to to the Mopeia/Zambezia census and associated assignation of spray/no-spray zones:

1. The identification of areas not yet censed through the generation of interactive satellite visualizations overlaid with cenus location data.

2. The algorithmic creation of buffered clusters for the designation of spray vs. no-spray zones.

This is an internal document meant to provide an overview of methodology/approach. Its results are preliminary, and the examples herein are just that: _examples_. 

# Census data collection validation

Data is actively being collected from the Mopeia area of Zambezia. One concern of the data collection is team is the completeness of the data being collected (ie, that all houses are censed). One way to ensure that houses are not being missed is to overlay the locations of censed houses with satellite images, followed by manual inspection of the overlays in order to identify not yet censed structures.

## Interactive (ad-hoc) examination


The below map is "interactive" in two ways: (1) it can be zoomed and scrolled so as to explore different areas and (2) locations (blue dots) can be clicked to reveal further information about the structure in question.

```{r}
mop_ll  <- spTransform(mop, CRS("+init=epsg:4326"))
proj4string(mop_ll) <- proj4string(zam)
color_indices <- as.numeric(factor(census$village))
colors <- colorRampPalette(c(brewer.pal(9, 'Spectral'),
                             brewer.pal(9, 'Set3'),
                             brewer.pal(9, 'Set2'),
                             brewer.pal(9, 'Set1')))(max(color_indices))
colors <- sample(colors, length(colors))
cols <- colors[color_indices]

leaflet(mop_ll) %>%
  addProviderTiles("Esri.WorldImagery") %>%
  addPolylines(color = 'red') %>%
  # addPolygons(stroke = FALSE, 
  #             smoothFactor = 0.2, 
  #             fillOpacity = 0.25,
  #             col = 'red') %>%
  addCircleMarkers(lng = census$lng,
  lat = census$lat,
  color = cols,
  fillColor = cols,
  radius = 2.5,
  opacity = 0,
  fillOpacity = 0.5,
  popup = paste0(census$META_INSTANCE_NAME, ' village name: ',
  census$LOCAL_VILLAGE_NAME, ' village number: ', census$village))
```

The above map is useful for manual _ad-hoc_ inspection. 

## Static (systematic) examination

However, we can also "grid" our area off and inspect each sector in a more systematic fashion.  What follows are examples of gridded areas for inspection by the data collection team. At this resolution, we would need to check approximately 300,000 gridded maps to ensure complete coverage for Mopeia. Though that number sounds daunting, the time this manual check takes could be rlatively low since (a) a majority of areas are known _a priori_ to have no inhabitants and therefore need no check, and (b) the generation of these maps requires no manual work.

What follows is a (random) sample of 4 of what these static maps look like.

```{r}
# 1000 x iterations
# 490 y iterations

# Define the boundary box
bb <- bbox(mop_ll)
xs <- as.numeric(bb[1,])
ys <- as.numeric(bb[2,])

# Define a dataframe of limits
xl <- seq(min(xs), max(xs), by = 0.1)
yl <- seq(min(ys), max(ys), by = 0.1)
b_df <- 
  expand.grid(x_min = xl, 
              y_min = yl)#,
              # x_max = xl,
              # y_max = yl)
# b_df <- b_df %>% filter(x_min < x_max,
#                         y_min < y_max)

selections <- c(15, 26, 50, 75)
for (i in selections){
  this_row <- b_df[i,]
  
  assign(paste0('g', i),
    ggmap(get_googlemap(center = c(lon = this_row$x_min,
                               lat = this_row$y_min),
                    zoom = 19,
                    maptype = 'satellite'),
          extent = 'device') +
  geom_point(data = census,
              aes(x = x, 
                  y = y),
             alpha = 0.4,
             color = 'darkred') +
  theme(axis.line = element_line(color = NA)) + 
    xlab("") + ylab(""))
}
multiplot(get(paste0('g', selections[1])),
          get(paste0('g', selections[2])),
          get(paste0('g', selections[3])),
          get(paste0('g', selections[4])),
          cols = 2)


```

# Cluster creation

The second geospatial issue that we must resolve is the creation of approximately 86 clusters for random assignation to "spray" / "no-spray" groups. These clusters have no size restrictions, but must contain a buffer of at least 1 kilometer, and buffers may not overlap (effectively making the buffer size 2 kilometers).


Our algorithmic approach for the creation of clusters is the k-means method, which creates k (86) clusters in a way so that the sum of squares of the distance from the points to the centroid of each cluster is minimized. Using this method, we assign all `r nrow(census_spatial)` locations to a cluster. 

```{r}
# CLUSTER CREATION

# Create a matrix of the coordinates of census
locations_matrix <- as.matrix(census[,c('lng', 'lat')])
  
# Run kmeans
n_clusters <- 86
x <- kmeans(locations_matrix, centers = n_clusters)
clusters <- x

# Get centroids into spatial
centroids <- clusters$centers
centroids <- data.frame(centroids)
coordinates(centroids) <- ~lng+lat
proj4string(centroids) <- CRS(original_proj4string)
centroids <- spTransform(centroids, CRS("+init=epsg:3347"))

# Use the clusters to assign colors
colors_palette <- colorRampPalette(brewer.pal(9, 'Set1'))(n_clusters)
colors <- colors_palette[x$cluster]
colors <- adjustcolor(colors, alpha.f = 0.8)

# plot(mop, col = 'lightgrey', border = NA)
# points(census_spatial, col = colors, pch = '.', cex = 0.3)

```

However, simple k-means is not sufficient, given the issue of the buffer. Importantly, once buffers are established, many locations must be flagged for removal (because they fall into the cluster+buffer zone of multiple clusters). In some cases, an entire cluster must be removed (since it falls into another cluster's area). Therefore, we have to first build more than 86 clusters in order to end up with 86 after the buffering.

```{r}
# Run kmeans
n_clusters <- 200
x <- kmeans(locations_matrix, centers = n_clusters)
clusters <- x

# Get centroids into spatial
centroids <- clusters$centers
centroids <- data.frame(centroids)
coordinates(centroids) <- ~lng+lat
proj4string(centroids) <- CRS(original_proj4string)
centroids <- spTransform(centroids, CRS("+init=epsg:3347"))

# Use the clusters to assign colors
colors_palette <- colorRampPalette(brewer.pal(9, 'Set1'))(n_clusters)
colors <- colors_palette[x$cluster]
colors <- adjustcolor(colors, alpha.f = 0.8)
# 
# plot(mop, col = 'lightgrey', border = NA)
# points(census_spatial, col = colors, pch = '.', cex = 0.3)
```

Having now built 200 clusters, we can proceed to draw buffers. We do this iteratively, starting with the largest cluster. For each cluster, once a buffer is drawn, any locations that are not members of that cluster (but fall within that cluster's buffer zone) are removed.

```{r}
# Iterative k means

# Create a dataframe of cluster numbers and number of homes associated
cluster_df <- data.frame(census_spatial)
cluster_df$cluster <- clusters$cluster
cluster_df <- cluster_df %>%
  group_by(cluster) %>%
  tally %>%
  ungroup %>%
  arrange(desc(n))

# Create a copy of census_spatial to modify
cs <- census_spatial

# Add a column for cluster
cs$cluster <- clusters$cluster

# Add a column (to be populated below) for whether it gets kept or not
cs$keep <- TRUE

# Create a row number (we'll use for indexing)
cs$row_number <- 1:nrow(cs)

# Cluster around points by cluster
buffer_list <- list()
for (i in 1:nrow(cluster_df)){

  # Get points and buffer for this cluster
  this_cluster <- cluster_df$cluster[i]
  these_points <- cs[cs$cluster == i,]
  points_buffered <- gBuffer(SpatialPoints(these_points), 
          width = 1000)
  proj4string(points_buffered) <- proj4string(cs)
  
  # Assign to a list of buffers
  buffer_list[[i]] <- points_buffered
  
    # If this is the first one, create a the_polygons
  # object to which we'll add
  if(i == 1){
    the_polygons <- points_buffered
    remove <- c()
  } else {
      # Check to see if the new points are in the buffer of another polygon
  in_another <-
    over(these_points, the_polygons, returnList = TRUE)
  in_another <- unlist(lapply(in_another, function(x){length(x) >= 1}))
  
  # Get which row numbers are in another polygon
  remove <- these_points$row_number[in_another]
  }
  
  # Flag in cs
  if(length(remove) > 0){
      cs$keep[remove] <- FALSE
  }
  
  # Combine this polygon with the previous polygons
  if(i > 1){
      the_polygons <- gUnion(the_polygons, points_buffered)
  }
  
  # Message
  # message(paste0('Just finished cluster number ', i))
}

# Get only keepers
keepers <- cs[cs$keep,]

# # Plot it
# plot(mop)
cols <- colors_palette[cs$cluster]
# 
# # Plot the polygons
# for (i in 1:nrow(cluster_df)){
# try({
#     this_cluster <- cluster_df$cluster[i]
#     these_points <- keepers[keepers$cluster == i,]
#     minimal <- gBuffer(SpatialPoints(these_points),
#                        width = 1)
#     points_buffered <- gBuffer(SpatialPoints(these_points), 
#             width = 1000)
#     proj4string(points_buffered) <- proj4string(cs)
#     plot(minimal, col = adjustcolor(cols[i], alpha.f = 0.3), add = TRUE)
#     plot(points_buffered, col = adjustcolor(cols[i], alpha.f = 0.3), add = TRUE)
#     points(these_points, col = cols[i], pch = 16, cex = 0.1)
#   })
# }


# Get counts again
new_counts <-
  data.frame(cs) %>%
  filter(keep) %>%
  group_by(cluster) %>%
  tally
```

Our clusters (prior to removing those locations within buffer zones) look like this. Note that many clusters have virtually no buffer at all, and houses from different clusters are nearly touching one another in some areas:

```{r}
cs_df <- data.frame(cs)
leaflet(mop_ll) %>%
  addProviderTiles("Stamen.Watercolor") %>%
  addCircleMarkers(lng = cs_df$lng,
  lat = cs_df$lat,
  color = cols,
  fillColor = cols,
  radius = 2.5,
  opacity = 0,
  fillOpacity = 0.5,
  popup = paste0('Cluster: ', cs_df$cluster, ' ', cs_df$META_INSTANCE_NAME, '\nvillage: ',
  cs_df$LOCAL_VILLAGE_NAME))
```

We define buffers of 1 kilomter. After defining the buffers (and removing the necessary locations which fell into buffer zones), they look like this:

```{r}
cs_df <- data.frame(cs) 
new_cols <- cols[cs_df$keep]
cs_df <- cs_df %>% filter(keep)
leaflet() %>%
  addProviderTiles("Stamen.Watercolor") %>%
  addCircleMarkers(lng = cs_df$lng,
  lat = cs_df$lat,
  color = new_cols,
  fillColor = new_cols,
  radius = 2.5,
  opacity = 0,
  fillOpacity = 0.5,
  popup = paste0('Cluster: ', cs_df$cluster, ' ', cs_df$META_INSTANCE_NAME, '\nvillage: ',
  cs_df$LOCAL_VILLAGE_NAME)) 
```

Finally, having designated our clusters, we randomly assign them to "spray" / "no-spray" status (blue = "spray", red = "no-spray").

```{r}
cluster_df$spray <- sample(c('spray', 'no spray'), nrow(cluster_df), replace = TRUE)
cs@data <- 
  left_join(cs@data,
            cluster_df %>%
              dplyr::select(-n),
            by = 'cluster')
cs_df <- data.frame(cs) %>% filter(keep)
cs_df$color <-
  ifelse(cs_df$spray == 'spray', 'blue', 'darkred')

leaflet(mop_ll) %>%
  addProviderTiles("Stamen.Watercolor") %>%
  addCircleMarkers(lng = cs_df$lng,
  lat = cs_df$lat,
  color = cs_df$color,
  fillColor = cs_df$color,
  radius = 2.5,
  opacity = 0,
  fillOpacity = 0.5,
  popup = paste0('Cluster: ', cs_df$cluster, ' ', cs_df$META_INSTANCE_NAME, '\nvillage: ',
  cs_df$LOCAL_VILLAGE_NAME))

```

For field workers' use, they will be provided with both satellite and road maps at the time of spraying (see below).

```{r}
leaflet(mop_ll) %>%
  addProviderTiles("Esri.WorldImagery") %>%
  addCircleMarkers(lng = cs_df$lng,
  lat = cs_df$lat,
  color = cs_df$color,
  fillColor = cs_df$color,
  radius = 2.5,
  opacity = 0,
  fillOpacity = 0.5,
  popup = paste0('Cluster: ', cs_df$cluster, ' ', cs_df$META_INSTANCE_NAME, '\nvillage: ',
  cs_df$LOCAL_VILLAGE_NAME))
```

```{r}
leaflet(mop_ll) %>%
  addProviderTiles("OpenStreetMap.Mapnik") %>%
  addCircleMarkers(lng = cs_df$lng,
  lat = cs_df$lat,
  color = cs_df$color,
  fillColor = cs_df$color,
  radius = 2.5,
  opacity = 0,
  fillOpacity = 0.5,
  popup = paste0('Cluster: ', cs_df$cluster, ' ', cs_df$META_INSTANCE_NAME, '\nvillage: ',
  cs_df$LOCAL_VILLAGE_NAME))
```


## Issues

### High exclusion rate

With such large buffer zones, a majority of locations have to be excluded in order to meet the number of required clusters. As of now (data collection not finished), `r nrow(census_spatial)` locations have been censed, but only `r length(which(cs$keep))` are able to be assigned a cluster (due to the fact that the rest fall into buffer zones). The number of eligible locations could be increased by either (a) decreasing the buffer or (b) decreasing the number of required clusters.

```{r}
df <- data.frame(Status = c('After', 'Before'),
                 Locations = c(nrow(census), length(which(cs$keep))))
levels(df$Status) <- c('Before', 'After')
ggplot(data =df,
       aes(x = Status, y = Locations)) +
  geom_bar(stat = 'identity', fill = 'orangered', alpha = 0.6) +
  theme_bw() +
  ggtitle('Effect of buffering on sample size')
  
```
