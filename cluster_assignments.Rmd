---
title: Cost-effectiveness evaluation of vector control strategies in Mozambique - cluster assignments
author: Joe Brew, Charfudin Sacoor, Carlos Chaccour, Molly Robertson, Francisco Saute
fig_height: 2.6
fig_width: 4
output:
  html_document:
    toc: true
    toc_float: true
    theme: yeti
---

```{r, echo = FALSE, warning = FALSE, message = FALSE, comment = NA, error= FALSE, cache = FALSE}
# No scientific notation
options(scipen=999)

# Packages 
library(xtable)
library(knitr)
library(ggplot2) 
# library(dplyr)
library(rgeos)
library(RColorBrewer)
library(Rmisc)

# Basic knitr options
opts_chunk$set(comment = NA, 
               echo = FALSE, 
               warning = FALSE, 
               message = FALSE, 
               error = TRUE, # Render report, even with errors
               cache = F)

```

```{r setup, include=FALSE, echo = FALSE}
library(knitr)
knit_engines$set(asis = function(options) {
  if (options$echo && options$eval) knit_child(text = options$code)
})
```


```{r}
#### READ IN AND CLEAN UP DATA
# Libraries
library(rgdal)
library(raster)
library(sp)
library(leaflet)
library(ggmap)

# Source script
source('lib/get_zambezia.R')

# Read in zambezia data
get_zambezia(get_fresh = FALSE, save = FALSE)

# Get a more nicely named core census file
census <- CENSUS_MOPEIA_CORE

# Get more nicely named geographic coordinate column names
census$lat <- census$y <- census$latitude <- census$GPC_LAT
census$lon <- census$lng <- census$longitude <-census$x <- census$GPC_LNG

# Get a shapefile for Mozambique
moz <- raster::getData('GADM', country = 'MOZ', level = 3)
moz2 <- raster::getData('GADM', country = 'MOZ', level = 2)

# Create a spatial version of census
census_spatial <- census
coordinates(census_spatial) <- ~x+y
proj4string(census_spatial) <- proj4string(moz)

# Subset the shapefile just to Zambezia
zam <- moz[moz@data$NAME_1 == 'Zambezia',]

# Subset further to just Mopeia
mop <- moz2[moz2@data$NAME_2 == 'Mopeia',]

# Save the original proj4string
original_proj4string <- proj4string(moz)

# Prepare ggmap-compatible objects
zam_fortified <- fortify(zam, id = ID_3)
mop_fortified <- fortify(mop, id = ID_3)
zam_gg <- get_map(location = c(lon = mean(census$lon, na.rm = TRUE),
                               lat = mean(census$lat, na.rm = TRUE)),
                  maptype = 'satellite')
mop_gg <- get_map(location = c(lon = mean(census$lon, na.rm = TRUE),
                               lat = mean(census$lat, na.rm = TRUE)),
                  maptype = 'satellite')

# Switch to a projected format
# Project
census_spatial <- spTransform(census_spatial, CRS( "+init=epsg:3347" ) )
mop <- spTransform(mop, CRS("+init=epsg:3347"))
# Later, we can switch back to lat/long:
# census_spatial <- spTransform(census_spatial, CRS("+init=epsg:4326"))
```

# Introduction

This document serves to explain both the methods and results for the algorithmic creation of buffered clusters for the designation of spray vs. no-spray zones for the "Cost-effectiveness evaluation of vector control strategies in Mozambique" study.

This is an internal document meant to provide an overview of methodology/approach. Its results are preliminary.

# Locations  

`r nrow(census)` locations have been identified by the census in the district of Mopeia. These locations (blue points), along with the border of the district (red), can be visualized below.

(Note: the map is interactive. Zoom in for a closer look, or click on a blue dot to see the house ID number and village name.)


```{r}
mop_ll  <- spTransform(mop, CRS("+init=epsg:4326"))
proj4string(mop_ll) <- proj4string(zam)

leaflet(mop_ll) %>%
  addProviderTiles("Esri.WorldImagery") %>%
  addPolylines(color = 'red') %>%
  # addPolygons(stroke = FALSE, 
  #             smoothFactor = 0.2, 
  #             fillOpacity = 0.25,
  #             col = 'red') %>%
  addCircleMarkers(lng = census$lng,
  lat = census$lat,
  color = colors,
  fillColor = 'blue',
  radius = 2.5,
  opacity = 0,
  fillOpacity = 0.5,
  popup = paste0(census$META_INSTANCE_NAME, '\nvillage: ',
  census$LOCAL_VILLAGE_NAME))
```


# Parameters

We must designate approximately 86 clusters for random assignation to "spray" / "no-spray" groups. These clusters have no size restrictions, but are subject to multiple constraints:

- Assignation must not divide villages (ie, one village must have exactly 1 spray/no-spray status).
- Each cluster must contain a buffer of at least 1 kilometer.
- Buffers may not overlap (effectively making the buffer size 2 kilometers).
- Units near the rim of the distrct should be excluded (for logistical purposes).
- There must be at least 18 children <5 years of age in each core area (at time of enrollment).
- Those children should be from different houses, ideally.
- The 86 clusters must be divided into 3 strata (with similarly sized clusters per strata).
- Mopeia sede should be excluded completely (?).

Our algorithmic approach for the creation of clusters is the k-means method, which creates k (86) clusters in a way so that the sum of squares of the distance from the points to the centroid of each cluster is minimized. Using this method, we assign all `r nrow(census_spatial)` locations to a cluster. 

```{r}
# CLUSTER CREATION

# Get only village and location for each datapoint
locations <- data.frame(census[,c('META_INSTANCE_NAME', 
                                  'LOCAL_VILLAGE_NAME', 
                                  'lng', 
                                  'lat',
                                  'x',
                                  'y')]) %>%
  dplyr::rename(village = LOCAL_VILLAGE_NAME,
                id = META_INSTANCE_NAME)

# # Create a matrix of the coordinates of census
# locations_matrix <- as.matrix(census[,c('lng', 'lat')])

# Get border of those points
coordinates(locations) <- ~x+y
x <- rgeos::gConvexHull(locations)

# Get border polygons for each location
polygons_list <- list()
villages <- sort(unique(locations$village))
for (i in 1:length(villages)){
  this_village = villages[i]
  message(paste0('Working on ', this_village, '.'))
  sub_locations <- locations[locations$village == this_village,]
  x <- rgeos::gConvexHull(sub_locations)
  plot(x, add = T, col = adjustcolor(sample(rainbow(1000), 1), alpha.f = 0.3),
       border = adjustcolor('black', alpha.f = 0.4), lwd = 0.2)
}

# Group by village
x <- locations %>%
  group_by(village) %>%
  summarise(houses = n()) %>%
  arrange(desc(village))

# OLD WAY---------------------
# Create a matrix of the coordinates of census
locations_matrix <- as.matrix(census[,c('lng', 'lat')])
  
# Run kmeans
n_clusters <- 86
x <- kmeans(locations_matrix, centers = n_clusters)
clusters <- x

# Get centroids into spatial
centroids <- clusters$centers
centroids <- data.frame(centroids)
coordinates(centroids) <- ~lng+lat
proj4string(centroids) <- CRS(original_proj4string)
centroids <- spTransform(centroids, CRS("+init=epsg:3347"))

# Use the clusters to assign colors
colors_palette <- colorRampPalette(brewer.pal(9, 'Set1'))(n_clusters)
colors <- colors_palette[x$cluster]
colors <- adjustcolor(colors, alpha.f = 0.8)

# plot(mop, col = 'lightgrey', border = NA)
# points(census_spatial, col = colors, pch = '.', cex = 0.3)

```

However, simple k-means is not sufficient, given the issue of the buffer. Importantly, once buffers are established, many locations must be flagged for removal (because they fall into the cluster+buffer zone of multiple clusters). In some cases, an entire cluster must be removed (since it falls into another cluster's area). Therefore, we have to first build more than 86 clusters in order to end up with 86 after the buffering.

```{r}
# Run kmeans
n_clusters <- 200
x <- kmeans(locations_matrix, centers = n_clusters)
clusters <- x

# Get centroids into spatial
centroids <- clusters$centers
centroids <- data.frame(centroids)
coordinates(centroids) <- ~lng+lat
proj4string(centroids) <- CRS(original_proj4string)
centroids <- spTransform(centroids, CRS("+init=epsg:3347"))

# Use the clusters to assign colors
colors_palette <- colorRampPalette(brewer.pal(9, 'Set1'))(n_clusters)
colors <- colors_palette[x$cluster]
colors <- adjustcolor(colors, alpha.f = 0.8)
# 
# plot(mop, col = 'lightgrey', border = NA)
# points(census_spatial, col = colors, pch = '.', cex = 0.3)
```

Having now built 200 clusters, we can proceed to draw buffers. We do this iteratively, starting with the largest cluster. For each cluster, once a buffer is drawn, any locations that are not members of that cluster (but fall within that cluster's buffer zone) are removed.

```{r}
# Iterative k means

# Create a dataframe of cluster numbers and number of homes associated
cluster_df <- data.frame(census_spatial)
cluster_df$cluster <- clusters$cluster
cluster_df <- cluster_df %>%
  group_by(cluster) %>%
  tally %>%
  ungroup %>%
  arrange(desc(n))

# Create a copy of census_spatial to modify
cs <- census_spatial

# Add a column for cluster
cs$cluster <- clusters$cluster

# Add a column (to be populated below) for whether it gets kept or not
cs$keep <- TRUE

# Create a row number (we'll use for indexing)
cs$row_number <- 1:nrow(cs)

# Cluster around points by cluster
buffer_list <- list()
for (i in 1:nrow(cluster_df)){

  # Get points and buffer for this cluster
  this_cluster <- cluster_df$cluster[i]
  these_points <- cs[cs$cluster == i,]
  points_buffered <- gBuffer(SpatialPoints(these_points), 
          width = 1000)
  proj4string(points_buffered) <- proj4string(cs)
  
  # Assign to a list of buffers
  buffer_list[[i]] <- points_buffered
  
    # If this is the first one, create a the_polygons
  # object to which we'll add
  if(i == 1){
    the_polygons <- points_buffered
    remove <- c()
  } else {
      # Check to see if the new points are in the buffer of another polygon
  in_another <-
    over(these_points, the_polygons, returnList = TRUE)
  in_another <- unlist(lapply(in_another, function(x){length(x) >= 1}))
  
  # Get which row numbers are in another polygon
  remove <- these_points$row_number[in_another]
  }
  
  # Flag in cs
  if(length(remove) > 0){
      cs$keep[remove] <- FALSE
  }
  
  # Combine this polygon with the previous polygons
  if(i > 1){
      the_polygons <- gUnion(the_polygons, points_buffered)
  }
  
  # Message
  # message(paste0('Just finished cluster number ', i))
}

# Get only keepers
keepers <- cs[cs$keep,]

# # Plot it
# plot(mop)
cols <- colors_palette[cs$cluster]
# 
# # Plot the polygons
# for (i in 1:nrow(cluster_df)){
# try({
#     this_cluster <- cluster_df$cluster[i]
#     these_points <- keepers[keepers$cluster == i,]
#     minimal <- gBuffer(SpatialPoints(these_points),
#                        width = 1)
#     points_buffered <- gBuffer(SpatialPoints(these_points), 
#             width = 1000)
#     proj4string(points_buffered) <- proj4string(cs)
#     plot(minimal, col = adjustcolor(cols[i], alpha.f = 0.3), add = TRUE)
#     plot(points_buffered, col = adjustcolor(cols[i], alpha.f = 0.3), add = TRUE)
#     points(these_points, col = cols[i], pch = 16, cex = 0.1)
#   })
# }


# Get counts again
new_counts <-
  data.frame(cs) %>%
  filter(keep) %>%
  group_by(cluster) %>%
  tally
```

Our clusters (prior to removing those locations within buffer zones) look like this. Note that many clusters have virtually no buffer at all, and houses from different clusters are nearly touching one another in some areas:

```{r}
cs_df <- data.frame(cs)
leaflet(mop_ll) %>%
  addProviderTiles("Stamen.Watercolor") %>%
  addCircleMarkers(lng = cs_df$lng,
  lat = cs_df$lat,
  color = cols,
  fillColor = cols,
  radius = 2.5,
  opacity = 0,
  fillOpacity = 0.5,
  popup = paste0('Cluster: ', cs_df$cluster, ' ', cs_df$META_INSTANCE_NAME, '\nvillage: ',
  cs_df$LOCAL_VILLAGE_NAME))
```

We define buffers of 1 kilomter. After defining the buffers (and removing the necessary locations which fell into buffer zones), they look like this:

```{r}
cs_df <- data.frame(cs) 
new_cols <- cols[cs_df$keep]
cs_df <- cs_df %>% filter(keep)
leaflet() %>%
  addProviderTiles("Stamen.Watercolor") %>%
  addCircleMarkers(lng = cs_df$lng,
  lat = cs_df$lat,
  color = new_cols,
  fillColor = new_cols,
  radius = 2.5,
  opacity = 0,
  fillOpacity = 0.5,
  popup = paste0('Cluster: ', cs_df$cluster, ' ', cs_df$META_INSTANCE_NAME, '\nvillage: ',
  cs_df$LOCAL_VILLAGE_NAME)) 
```

Finally, having designated our clusters, we randomly assign them to "spray" / "no-spray" status (blue = "spray", red = "no-spray").

```{r}
cluster_df$spray <- sample(c('spray', 'no spray'), nrow(cluster_df), replace = TRUE)
cs@data <- 
  left_join(cs@data,
            cluster_df %>%
              dplyr::select(-n),
            by = 'cluster')
cs_df <- data.frame(cs) %>% filter(keep)
cs_df$color <-
  ifelse(cs_df$spray == 'spray', 'blue', 'darkred')

leaflet(mop_ll) %>%
  addProviderTiles("Stamen.Watercolor") %>%
  addCircleMarkers(lng = cs_df$lng,
  lat = cs_df$lat,
  color = cs_df$color,
  fillColor = cs_df$color,
  radius = 2.5,
  opacity = 0,
  fillOpacity = 0.5,
  popup = paste0('Cluster: ', cs_df$cluster, ' ', cs_df$META_INSTANCE_NAME, '\nvillage: ',
  cs_df$LOCAL_VILLAGE_NAME))

```

For field workers' use, they will be provided with both satellite and road maps at the time of spraying (see below).

```{r}
leaflet(mop_ll) %>%
  addProviderTiles("Esri.WorldImagery") %>%
  addCircleMarkers(lng = cs_df$lng,
  lat = cs_df$lat,
  color = cs_df$color,
  fillColor = cs_df$color,
  radius = 2.5,
  opacity = 0,
  fillOpacity = 0.5,
  popup = paste0('Cluster: ', cs_df$cluster, ' ', cs_df$META_INSTANCE_NAME, '\nvillage: ',
  cs_df$LOCAL_VILLAGE_NAME))
```

```{r}
leaflet(mop_ll) %>%
  addProviderTiles("OpenStreetMap.Mapnik") %>%
  addCircleMarkers(lng = cs_df$lng,
  lat = cs_df$lat,
  color = cs_df$color,
  fillColor = cs_df$color,
  radius = 2.5,
  opacity = 0,
  fillOpacity = 0.5,
  popup = paste0('Cluster: ', cs_df$cluster, ' ', cs_df$META_INSTANCE_NAME, '\nvillage: ',
  cs_df$LOCAL_VILLAGE_NAME))
```


## Issues

### High exclusion rate

With such large buffer zones, a majority of locations have to be excluded in order to meet the number of required clusters. As of now (data collection not finished), `r nrow(census_spatial)` locations have been censed, but only `r length(which(cs$keep))` are able to be assigned a cluster (due to the fact that the rest fall into buffer zones). The number of eligible locations could be increased by either (a) decreasing the buffer or (b) decreasing the number of required clusters.

```{r}
df <- data.frame(Status = c('After', 'Before'),
                 Locations = c(nrow(census), length(which(cs$keep))))
levels(df$Status) <- c('Before', 'After')
ggplot(data =df,
       aes(x = Status, y = Locations)) +
  geom_bar(stat = 'identity', fill = 'orangered', alpha = 0.6) +
  theme_bw() +
  ggtitle('Effect of buffering on sample size')
  
```
