---
title: "Clean maps"
author: "CISM"
fig_width: 4
output:
  html_document:
    theme: yeti
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
fig_height: 2.6
---
```{r, echo = FALSE, warning = FALSE, message = FALSE, comment = NA, error= FALSE, cache = FALSE}
# No scientific notation
options(scipen=999)

# Packages 
library(xtable)
library(knitr)
library(ggplot2) 
# library(dplyr)
library(rgeos)
library(RColorBrewer)
library(Rmisc)
# Libraries
library(rgdal)
library(raster)
library(sp)
library(leaflet)
library(ggmap)
library(readxl)
library(dplyr)
library(readr)
library(geosphere)

# Basic knitr options
opts_chunk$set(comment = NA, 
               echo = FALSE, 
               warning = FALSE, 
               message = FALSE, 
               error = TRUE, # Render report, even with errors
               cache = F)

# Helpers
source('lib/get_zambezia.R')
source('lib/helpers.R')
```

```{r setup, include=FALSE, echo = FALSE}
library(knitr)
knit_engines$set(asis = function(options) {
  if (options$echo && options$eval) knit_child(text = options$code)
})
```


# Introduction

This document contains maps and tables pertaining to the (cleaned) Mopeia trial data. It was produced mid day (GMT +2) on Monday, October 24th, 2016. It uses data sent from Charfudin Sacoor to Joe Brew on the morning of Monday, October 24th, 2016 (`Limpesa_Final__241016_For maps.xlsx`).

```{r}
#### READ IN AND CLEAN UP DATA

# Read in final dataset, as given by Orvahlo on October 24, 2016
census <- read_excel('Limpesa_Final__241016_For maps.xlsx')

# Get more nicely named geographic coordinate column names
census$lat <- census$y <- census$latitude <- census$gpc_lat
census$lon <- census$lng <- census$longitude <-census$x <- census$gpc_lng

# Get a shapefile for Mozambique
moz <- raster::getData('GADM', country = 'MOZ', level = 3)
moz2 <- raster::getData('GADM', country = 'MOZ', level = 2)

# GET CORRECT FINAL COLUMNS, AS EXPLAINED IN EMAIL
# Get a village number
census$village_number <- census$`village number_final`
census$administrative_post <- census$administrative_post_final
census$house_number <- census$houseno_Final_1
census$locality <- census$locality_Final

# Create a spatial version of census
census_spatial <- census
coordinates(census_spatial) <- ~x+y
proj4string(census_spatial) <- proj4string(moz)

# Subset the shapefile just to Zambezia
zam <- moz[moz@data$NAME_1 == 'Zambezia',]

# Subset further to just Mopeia
mop <- moz2[moz2@data$NAME_2 == 'Mopeia',]

# Save the original proj4string
original_proj4string <- proj4string(moz)

# Prepare ggmap-compatible objects
zam_fortified <- fortify(zam, id = ID_3)
mop_fortified <- fortify(mop, id = ID_3)
zam_gg <- get_map(location = c(lon = mean(census$lon, na.rm = TRUE),
                               lat = mean(census$lat, na.rm = TRUE)),
                  maptype = 'satellite')
mop_gg <- get_map(location = c(lon = mean(census$lon, na.rm = TRUE),
                               lat = mean(census$lat, na.rm = TRUE)),
                  maptype = 'satellite')

# Switch to a projected format
# Project
census_spatial <- spTransform(census_spatial, CRS( "+init=epsg:3347" ) )
mop <- spTransform(mop, CRS("+init=epsg:3347"))
# Later, we can switch back to lat/long:
census_spatial_ll <- spTransform(census_spatial, CRS("+init=epsg:4326"))
mop_ll  <- spTransform(mop, CRS("+init=epsg:4326"))
# proj4string(mop_ll) <- proj4string(zam)
```



```{r}
if('temp.RData' %in% dir()){
  load('temp.RData')
} else {
  # Make a dataframe of just villages (with cluster assignments)
  village_df <- make_village_df(census = census)
  
  # Identify problems
  identify_problems()
  
  # Remove incorrect houses
  census <- census[which(!census$house_number %in% incorrect_houses),]
  census_spatial <- census_spatial[which(!census_spatial$house_number %in% incorrect_houses),]
  census_spatial_ll <- census_spatial_ll[which(!census_spatial_ll$house_number %in% incorrect_houses),]

  # Identify buffers
  Sys.time()
  census_spatial_ll <- identify_buffers(census_spatial_ll)
  Sys.time()
  save.image('temp.RData')  
}


# Resource helpers
source('lib/helpers.R')

# Get spray status
# spray_status <- read_excel('20160817 Mopeia spray-no spray random list.xlsx')
spray_status <- read_excel('Final spray no spray list.xlsx')

# Clean up
spray_status <- spray_status[,1:11]
names(spray_status) <-
  tolower(gsub('.', '_', names(spray_status), fixed = TRUE))
names(spray_status) <- gsub(' |-', '_', names(spray_status))

# Remove NA rows
spray_status <- 
  spray_status %>%
  filter(!is.na(cluster))

# Create a status column
spray_status$status <- spray_status$spray_status
spray_status$status <-
  ifelse(is.na(spray_status$status),
         FALSE,
         ifelse(spray_status$status == 'YES',
                TRUE,
                NA))
spray_status$spray_status <- NULL

# Get village-specific spray status
village_df$status <- NA
for (i in 1:nrow(spray_status)){
  this_cluster <- spray_status$cluster[i]
  this_spray_status <- spray_status$status[i]
  these_villages <- unlist(lapply(strsplit(spray_status$village_code[i], split = ','), as.numeric))
  village_df$status[village_df$village_number %in% these_villages] <- this_spray_status
}
```

# Village-specific maps

The below maps show each village, as well as the boundary of that village's area.

```{r, eval = TRUE}
maps <- lapply(village_df$row_number, function(x){
  leaflet_village_clean(x)
})

htmltools::tagList(maps)
```


# Master map

```{r}
leaflet_village_master()
```


```{r}
# Also create a master map
master_map()
```
