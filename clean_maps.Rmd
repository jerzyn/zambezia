---
title: "Clean maps"
author: "CISM"
fig_width: 4
output:
  html_document:
    theme: yeti
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
fig_height: 2.6
---
```{r, echo = FALSE, warning = FALSE, message = FALSE, comment = NA, error= FALSE, cache = FALSE}
# No scientific notation
options(scipen=999)

# Packages 
library(xtable)
library(knitr)
library(ggplot2) 
# library(dplyr)
library(rgeos)
library(RColorBrewer)
library(Rmisc)
# Libraries
library(rgdal)
library(raster)
library(sp)
library(leaflet)
library(ggmap)
library(readxl)
library(dplyr)
library(readr)
library(geosphere)

# Basic knitr options
opts_chunk$set(comment = NA, 
               echo = FALSE, 
               warning = FALSE, 
               message = FALSE, 
               error = TRUE, # Render report, even with errors
               cache = F)

# Helpers
source('lib/get_zambezia.R')
source('lib/helpers.R')
```

```{r setup, include=FALSE, echo = FALSE}
library(knitr)
knit_engines$set(asis = function(options) {
  if (options$echo && options$eval) knit_child(text = options$code)
})
```


# Introduction

This document contains maps and tables pertaining to the (cleaned) Mopeia trial data. It was produced mid day (GMT +2) on Monday, October 24th, 2016. It uses data sent from Charfudin Sacoor to Joe Brew on the morning of Monday, October 24th, 2016 (`Limpesa_Final__241016_For maps.xlsx`).


In addition to the manual cleaning carried out by the demography team, approximately 2,300 houses were flagged and removed in algorithmic cleaning.

```{r}
#### READ IN AND CLEAN UP DATA

# Read in final dataset, as given by Orvahlo on October 24, 2016
census <- read_excel('Limpesa_Final__241016_For maps.xlsx')

# Get more nicely named geographic coordinate column names
census$lat <- census$y <- census$latitude <- census$gpc_lat
census$lon <- census$lng <- census$longitude <-census$x <- census$gpc_lng

# Get a shapefile for Mozambique
moz <- raster::getData('GADM', country = 'MOZ', level = 3)
moz2 <- raster::getData('GADM', country = 'MOZ', level = 2)

# GET CORRECT FINAL COLUMNS, AS EXPLAINED IN EMAIL
# Get a village number
census$village_number <- census$`village number_final`
census$administrative_post <- census$administrative_post_final
census$house_number <- census$houseno_Final_1
census$locality <- census$locality_Final


# Remove all NA rows
census <- census %>%
  filter(!is.na(lng),
         !is.na(lat),
         !is.na(village_number),
         !is.na(house_number))


# Save old version of census
census_old <- census

# Create a spatial version of census
census_spatial <- census
coordinates(census_spatial) <- ~x+y
proj4string(census_spatial) <- proj4string(moz)

# Subset the shapefile just to Zambezia
zam <- moz[moz@data$NAME_1 == 'Zambezia',]

# Subset further to just Mopeia
mop <- moz2[moz2@data$NAME_2 == 'Mopeia',]

# Save the original proj4string
original_proj4string <- proj4string(moz)

# Prepare ggmap-compatible objects
zam_fortified <- fortify(zam, id = ID_3)
mop_fortified <- fortify(mop, id = ID_3)
zam_gg <- get_map(location = c(lon = mean(census$lon, na.rm = TRUE),
                               lat = mean(census$lat, na.rm = TRUE)),
                  maptype = 'satellite')
mop_gg <- get_map(location = c(lon = mean(census$lon, na.rm = TRUE),
                               lat = mean(census$lat, na.rm = TRUE)),
                  maptype = 'satellite')

# Switch to a projected format
# Project
census_spatial <- spTransform(census_spatial, CRS( "+init=epsg:3347" ) )
mop <- spTransform(mop, CRS("+init=epsg:3347"))
# Later, we can switch back to lat/long:
census_spatial_ll <- spTransform(census_spatial, CRS("+init=epsg:4326"))
mop_ll  <- spTransform(mop, CRS("+init=epsg:4326"))
# proj4string(mop_ll) <- proj4string(zam)
```



```{r}
if('temp.RData' %in% dir()){
  load('temp.RData')
} else {
  # Make a dataframe of just villages (with cluster assignments)
  village_df <- make_village_df(census = census)
  
  # Get a distance matrix (takes 2-3 minutes)
  distance_matrix <- get_distance_matrix(spatial_ll_census = census_spatial_ll)
  
  # Identify problems
  identify_problems()
  census$problematic <- census$house_number %in% incorrect_houses
  census_spatial$problematic <- census_spatial$house_number %in% incorrect_houses
  census_spatial_ll$problematic <- census_spatial_ll$house_number %in% incorrect_houses
  
  # SUBSET TO REMOVE PROBLEMATIC
  # Get distance matrix after subset
  distance_matrix_old <- distance_matrix
  distance_matrix <- distance_matrix[!census$problematic,
                                         !census$problematic]
  
  # Identify the nearest neighbors of each house
  nn <- nearest_neighbor(census_spatial_ll = census_spatial_ll,
                             distance_matrix_old = distance_matrix_old,
                             n = 5)
  census$nearest_neighbors <- nn
  census_old$nearest_neighbors <- nn
  census_spatial$nearest_neighbors <- nn
  census_spatial_ll$nearest_neighbors <- nn
  
  # Remove incorrect houses
  census <- census[which(!census$house_number %in% incorrect_houses),]
  census_spatial <- census_spatial[which(!census_spatial$house_number %in% incorrect_houses),]
  census_spatial_ll <- census_spatial_ll[which(!census_spatial_ll$house_number %in% incorrect_houses),]
  
  # Identify buffers
  Sys.time()
  census_spatial_ll <- identify_buffers(spatial_ll_census = census_spatial_ll,
                       distances = distance_matrix)
  census_spatial$within_1k_not_village <- census_spatial_ll$within_1k_not_village
  census_spatial$buffer <- census_spatial_ll$buffer
  census$within_1k_not_village <- census_spatial_ll$within_1k_not_village
  census$buffer <- census_spatial_ll$buffer
  Sys.time()
  save.image('temp.RData')  
}

# Resource helpers
source('lib/helpers.R')

# Get spray status
spray_status <- read_excel('Final spray no spray list.xlsx')

# Clean up
spray_status <- spray_status[,1:11]
names(spray_status) <-
  tolower(gsub('.', '_', names(spray_status), fixed = TRUE))
names(spray_status) <- gsub(' |-', '_', names(spray_status))

# Remove NA rows
spray_status <- 
  spray_status %>%
  filter(!is.na(cluster))

# Create a status column
spray_status$status <- spray_status$spray_status
spray_status$status <-
  ifelse(is.na(spray_status$status),
         FALSE,
         ifelse(spray_status$status == 'YES',
                TRUE,
                NA))
spray_status$spray_status <- NULL

# Get village-specific spray status
village_df$status <- NA
for (i in 1:nrow(spray_status)){
  this_cluster <- spray_status$cluster[i]
  this_spray_status <- spray_status$status[i]
  these_villages <- unlist(lapply(strsplit(spray_status$village_code[i], split = ','), as.numeric))
  village_df$status[village_df$village_number %in% these_villages] <- this_spray_status
}

# Get table for Edgar, requested 25 Oct
edgar <-
  left_join(x = census_old,
            y = census %>%
              filter(!duplicated(house_number)) %>%
              mutate(problematic = FALSE) %>%
              dplyr::select(house_number, problematic),
            by = 'house_number') %>%
  mutate(problematic = ifelse(is.na(problematic), TRUE, problematic)) %>%
  arrange(desc(problematic))
edgar <- edgar[,unique(c('house_number', 
                         'village_number', 
                         'problematic', 
                         'nearest_neighbors', 
                         names(edgar)))]
write_csv(edgar, '~/Desktop/edgar_with_neighbors.csv')
```

# Village-specific maps

The below maps show each village, as well as the boundary of that village's area.

```{r, eval = TRUE}
maps <- lapply(village_df$row_number, function(x){
  leaflet_village_clean(x)
})

htmltools::tagList(maps)
```


# Master map

```{r}
leaflet_village_master()
```


```{r}
# Also create a master map
master_map()
```
