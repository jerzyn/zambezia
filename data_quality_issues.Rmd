---
title: Cost-effectiveness evaluation of vector control strategies in Mozambique - data quality issues
author: Joe Brew, Charfudin Sacoor, Carlos Chaccour, Francisco Saute
fig_height: 2.6
fig_width: 4
output:
  html_document:
    toc: true
    toc_float: true
    theme: yeti
---

```{r, echo = FALSE, warning = FALSE, message = FALSE, comment = NA, error= FALSE, cache = FALSE}
# No scientific notation
options(scipen=999)

# Packages 
library(xtable)
library(knitr)
library(ggplot2) 
# library(dplyr)
library(rgeos)
library(RColorBrewer)
library(Rmisc)

# Basic knitr options
opts_chunk$set(comment = NA, 
               echo = FALSE, 
               warning = FALSE, 
               message = FALSE, 
               error = TRUE, # Render report, even with errors
               cache = F)

```

```{r setup, include=FALSE, echo = FALSE}
library(knitr)
knit_engines$set(asis = function(options) {
  if (options$echo && options$eval) knit_child(text = options$code)
})
```


```{r}
#### READ IN AND CLEAN UP DATA
# Libraries
library(rgdal)
library(raster)
library(sp)
library(leaflet)
library(ggmap)

# Source script
source('lib/get_zambezia.R')

# Read in zambezia data
get_zambezia(get_fresh = FALSE, save = FALSE)

# Get a more nicely named core census file
census <- CENSUS_MOPEIA_CORE

# Get more nicely named geographic coordinate column names
census$lat <- census$y <- census$latitude <- census$GPC_LAT
census$lon <- census$lng <- census$longitude <-census$x <- census$GPC_LNG

# Get a shapefile for Mozambique
moz <- raster::getData('GADM', country = 'MOZ', level = 3)
moz2 <- raster::getData('GADM', country = 'MOZ', level = 2)

# Create a spatial version of census
census_spatial <- census
coordinates(census_spatial) <- ~x+y
proj4string(census_spatial) <- proj4string(moz)

# Subset the shapefile just to Zambezia
zam <- moz[moz@data$NAME_1 == 'Zambezia',]

# Subset further to just Mopeia
mop <- moz2[moz2@data$NAME_2 == 'Mopeia',]

# Save the original proj4string
original_proj4string <- proj4string(moz)

# Prepare ggmap-compatible objects
zam_fortified <- fortify(zam, id = ID_3)
mop_fortified <- fortify(mop, id = ID_3)
zam_gg <- get_map(location = c(lon = mean(census$lon, na.rm = TRUE),
                               lat = mean(census$lat, na.rm = TRUE)),
                  maptype = 'satellite')
mop_gg <- get_map(location = c(lon = mean(census$lon, na.rm = TRUE),
                               lat = mean(census$lat, na.rm = TRUE)),
                  maptype = 'satellite')

# Switch to a projected format
# Project
census_spatial <- spTransform(census_spatial, CRS( "+init=epsg:3347" ) )
mop <- spTransform(mop, CRS("+init=epsg:3347"))
# Later, we can switch back to lat/long:
# census_spatial <- spTransform(census_spatial, CRS("+init=epsg:4326"))
```

# Introduction

This document serves to explain the current _Ã©tat de l'art_ of the data collection, cluster creation process and algorithmic creation of buffered clusters for the designation of spray vs. no-spray zones for the "Cost-effectiveness evaluation of vector control strategies in Mozambique" study.

This is an internal document meant to provide an overview of methodology/approach. Its results are preliminary.

# The data

## Datasets

The datasets being used are `CENSUS_MOPEIA_CORE` and `CENSUS_MOPEIA_CHILDREN_INFO`. The former is referred to simply as the "census".

## Terminology  

The term "village" refers to the the `LOCAL_VILLAGE_NAME` column in the census data. The terms "ID" or "Household ID" refer to the `META_INSTANCE_NAME` column in the census data.

## Locations  

`r nrow(census)` locations have been identified by the census in the district of Mopeia. These locations (blue points), along with the border of the district (red), can be visualized below.

(Note: the map is interactive. Zoom in for a closer look, or click on a blue dot to see the house ID number and village name.)


```{r}
mop_ll  <- spTransform(mop, CRS("+init=epsg:4326"))
proj4string(mop_ll) <- proj4string(zam)

leaflet(mop_ll) %>%
  addProviderTiles("Esri.WorldImagery") %>%
  addPolylines(color = 'red') %>%
  # addPolygons(stroke = FALSE, 
  #             smoothFactor = 0.2, 
  #             fillOpacity = 0.25,
  #             col = 'red') %>%
  addCircleMarkers(lng = census$lng,
  lat = census$lat,
  color = colors,
  fillColor = 'blue',
  radius = 2.5,
  opacity = 0,
  fillOpacity = 0.5,
  popup = paste0(census$META_INSTANCE_NAME, '\nvillage: ',
  census$LOCAL_VILLAGE_NAME))
```

# Issues

## Inconsistent village naming/spelling  

In the raw data, there are `r length(unique(census$LOCAL_VILLAGE_NAME))` unique village names. This is far more than there _should_ be. Many of the errors are due to obvious spelling issues; however, in some cases, the `LOCAL_VILLAGE_NAME` is so inaccurate as to be incomprehensible (ie, `04`, `ABRIL`, or `,AGAIO`).

The below table shows all village names, along with the number of houses associated with that village.

```{r}
temp <- 
  census %>%
  group_by(Village = LOCAL_VILLAGE_NAME) %>%
  summarise(Houses = n())
DT::datatable(temp)
```

## Overlapping village boundaries

In order to properly designate village borders and buffers, it is essential to demarcate which areas fall into which village. By definition, any point can be part of no more than one village. However, with the current raw data,there is a great deal of overlap.

The below map shows each village's boundaries, as calculated through the Convex Hull of each village's included coordinates. In theory, there should be no overlapping whatsoever.

```{r, fig.width = 7, fig.height = 7}
# CLUSTER CREATION

# Get only village and location for each datapoint
locations <- data.frame(census[,c('META_INSTANCE_NAME', 
                                  'LOCAL_VILLAGE_NAME', 
                                  'lng', 
                                  'lat',
                                  'x',
                                  'y')]) %>%
  dplyr::rename(village = LOCAL_VILLAGE_NAME,
                id = META_INSTANCE_NAME)

# # Create a matrix of the coordinates of census
# locations_matrix <- as.matrix(census[,c('lng', 'lat')])

# Get border of those points
coordinates(locations) <- ~x+y
proj4string(locations) <- proj4string(moz)
x <- rgeos::gConvexHull(locations)

# Plot Mopeia
mop_map <- mop
mop_map <- spTransform(mop_map, proj4string(moz))
plot(mop_map)

# Get border polygons for each location
polygons_list <- list()
villages <- sort(unique(locations$village))
for (i in 1:length(villages)){
  this_village = villages[i]
  message(paste0('Working on ', this_village, '.'))
  sub_locations <- locations[locations$village == this_village,]
  x <- rgeos::gConvexHull(sub_locations)
  plot(x, add = T, col = adjustcolor(sample(rainbow(1000), 1), alpha.f = 0.15),
       border = adjustcolor('black', alpha.f = 0.4), lwd = 0.2)
}
```

To help elucidate potential causes for the overly large and overlapping villages (above), the below table shows each household location, its official village designation, as well as the names of those villages in whose boundaries the house's locations falls. Note: this is just a sample of the first 100 houses in the data (populating this report with all `r nrow(census)` houses would be too large); if you would like all `r nrow(census)` houses, let me know, and I'll send a "flat" file (ie, a `.csv`) with that location.

```{r}
temp <-
  locations
temp$also_in <- NA
for (i in 1:100){
  message(paste0(i, ' of ', nrow(temp)))
  sub_temp <- temp[i,]
  overs <- rep(NA, length(villages))
  for (j in 1:length(villages)){
    this_village = villages[j]
    sub_locations <- locations[locations$village == this_village,]
    if(nrow(sub_locations) > 2){
      x <- rgeos::gConvexHull(sub_locations)
      overs[j] <- over(sub_temp, polygons(x))
    }
  }
  temp$also_in[i] <- 
    paste0(villages[which(!is.na(overs))], collapse = ', ')
}

temp_df <- temp@data
temp_df <- temp_df[1:100,]
names(temp_df) <- Hmisc::capitalize(gsub('_', ' ', names(temp_df)))
DT::datatable(temp_df)
```