---
title: Cost-effectiveness evaluation of vector control strategies in Mozambique - data quality issues
author: Joe Brew, Charfudin Sacoor, Carlos Chaccour, Francisco Saute
fig_height: 2.6
fig_width: 4
output:
  html_document:
    toc: true
    toc_float: true
    theme: yeti
---

```{r, echo = FALSE, warning = FALSE, message = FALSE, comment = NA, error= FALSE, cache = FALSE}
# No scientific notation
options(scipen=999)

# Packages 
library(xtable)
library(knitr)
library(ggplot2) 
# library(dplyr)
library(rgeos)
library(RColorBrewer)
library(Rmisc)

# Basic knitr options
opts_chunk$set(comment = NA, 
               echo = FALSE, 
               warning = FALSE, 
               message = FALSE, 
               error = TRUE, # Render report, even with errors
               cache = F)

```

```{r setup, include=FALSE, echo = FALSE}
library(knitr)
knit_engines$set(asis = function(options) {
  if (options$echo && options$eval) knit_child(text = options$code)
})
```


```{r}
#### READ IN AND CLEAN UP DATA
# Libraries
library(rgdal)
library(raster)
library(sp)
library(leaflet)
library(ggmap)

# Source script
source('lib/get_zambezia.R')

# Read in zambezia data
get_zambezia(get_fresh = FALSE, save = FALSE)

# Get a more nicely named core census file
census <- CENSUS_MOPEIA_CORE

# Get more nicely named geographic coordinate column names
census$lat <- census$y <- census$latitude <- census$GPC_LAT
census$lon <- census$lng <- census$longitude <-census$x <- census$GPC_LNG

# Get a shapefile for Mozambique
moz <- raster::getData('GADM', country = 'MOZ', level = 3)
moz2 <- raster::getData('GADM', country = 'MOZ', level = 2)

# Create a spatial version of census
census_spatial <- census
coordinates(census_spatial) <- ~x+y
proj4string(census_spatial) <- proj4string(moz)

# Subset the shapefile just to Zambezia
zam <- moz[moz@data$NAME_1 == 'Zambezia',]

# Subset further to just Mopeia
mop <- moz2[moz2@data$NAME_2 == 'Mopeia',]

# Save the original proj4string
original_proj4string <- proj4string(moz)

# Prepare ggmap-compatible objects
zam_fortified <- fortify(zam, id = ID_3)
mop_fortified <- fortify(mop, id = ID_3)
zam_gg <- get_map(location = c(lon = mean(census$lon, na.rm = TRUE),
                               lat = mean(census$lat, na.rm = TRUE)),
                  maptype = 'satellite')
mop_gg <- get_map(location = c(lon = mean(census$lon, na.rm = TRUE),
                               lat = mean(census$lat, na.rm = TRUE)),
                  maptype = 'satellite')

# Switch to a projected format
# Project
census_spatial <- spTransform(census_spatial, CRS( "+init=epsg:3347" ) )
mop <- spTransform(mop, CRS("+init=epsg:3347"))
# Later, we can switch back to lat/long:
# census_spatial <- spTransform(census_spatial, CRS("+init=epsg:4326"))
```

# Introduction

This document serves to explain the current _Ã©tat de l'art_ of the data collection, cluster creation process and algorithmic creation of buffered clusters for the designation of spray vs. no-spray zones for the "Cost-effectiveness evaluation of vector control strategies in Mozambique" study.

This is an internal document meant to provide an overview of methodology/approach. Its results are preliminary.

# The data

## Datasets

The datasets being used are `CENSUS_MOPEIA_CORE` and `CENSUS_MOPEIA_CHILDREN_INFO`. The former is referred to simply as the "census".

## Terminology  

In previous reports, the term "village" referred to the the `LOCAL_VILLAGE_NAME` column in the census data. However, for simplicity's sake, we are now using village number (which is parsed from the 5th to 8th digits of the `HOUSEHOLD_NUMBER` variable. The terms "ID" or "Household ID" refer to the `META_INSTANCE_NAME` column in the census data.

```{r}
census$village <- as.numeric(lapply(strsplit(census$HOUSEHOLD_NUMBER, split = '-'), function(x){x[2]}))
```

## Locations  

`r nrow(census)` locations have been identified by the census in the district of Mopeia. These locations (colored by their village), along with the border of the district (red), can be visualized below.

(Note: the map is interactive. Zoom in for a closer look, or click on a blue dot to see the house ID number and village name.)


```{r}
mop_ll  <- spTransform(mop, CRS("+init=epsg:4326"))
proj4string(mop_ll) <- proj4string(zam)
color_indices <- as.numeric(factor(census$village))
colors <- colorRampPalette(c(brewer.pal(9, 'Spectral'),
                             brewer.pal(9, 'Set3'),
                             brewer.pal(9, 'Set2'),
                             brewer.pal(9, 'Set1')))(max(color_indices))
colors <- sample(colors, length(colors))
cols <- colors[color_indices]

leaflet(mop_ll) %>%
  addProviderTiles("Esri.WorldImagery") %>%
  addPolylines(color = 'red') %>%
  # addPolygons(stroke = FALSE, 
  #             smoothFactor = 0.2, 
  #             fillOpacity = 0.25,
  #             col = 'red') %>%
  addCircleMarkers(lng = census$lng,
  lat = census$lat,
  color = cols,
  fillColor = cols,
  radius = 2.5,
  opacity = 0,
  fillOpacity = 0.5,
  popup = paste0(census$META_INSTANCE_NAME, ' village name: ',
  census$LOCAL_VILLAGE_NAME, ' village number: ', census$village))
```

# Issues

## Inconsistent village naming/spelling  

In the raw data, there are `r length(unique(census$LOCAL_VILLAGE_NAME))` unique village names, bt only `r length(unique(census$village))` village numbers. The former is far more than there _should_ be. Many of the errors are due to obvious spelling issues; however, in some cases, the `LOCAL_VILLAGE_NAME` is so inaccurate as to be incomprehensible (ie, `04`, `ABRIL`, or `,AGAIO`).

The below table shows all village names, along with the number of houses associated with that village.

```{r}
temp <- 
  census %>%
  group_by(Village = LOCAL_VILLAGE_NAME) %>%
  summarise(Houses = n())
DT::datatable(temp)
```

For this reason, we focus on village number (parsed from `HOUSEHOLD_NUMBER`). The below table shows all village numbers, along with the number of houses associated with that village.

```{r}
temp <- 
  census %>%
  group_by(Village = village) %>%
  summarise(Houses = n())
DT::datatable(temp)
```


## Overlapping village boundaries

In order to properly designate village borders and buffers, it is essential to demarcate which areas fall into which village. By definition, any point can be part of no more than one village. We eliminate much of the overlap by using village numbers instead of village names. However, there is stil some overlap.

The below map shows each village's boundaries, as calculated through the Convex Hull of each village's included coordinates. In theory, there should be no overlapping whatsoever.

```{r, fig.width = 7, fig.height = 7}
# CLUSTER CREATION

# Get only village and location for each datapoint
locations <- data.frame(census[,c('META_INSTANCE_NAME', 
                                  'village', 
                                  'lng', 
                                  'lat',
                                  'x',
                                  'y')]) %>%
  dplyr::rename(id = META_INSTANCE_NAME)

# # Create a matrix of the coordinates of census
# locations_matrix <- as.matrix(census[,c('lng', 'lat')])

# Get border of those points
coordinates(locations) <- ~x+y
proj4string(locations) <- proj4string(moz)
x <- rgeos::gConvexHull(locations)

# Plot Mopeia
mop_map <- mop
mop_map <- spTransform(mop_map, proj4string(moz))
plot(mop_map)

# Get border polygons for each location
polygons_list <- list()
villages <- sort(unique(locations$village))
areas <- rep(NA, length(villages))
houses <- rep(NA, length(villages))
for (i in 1:length(villages)){
  this_village = villages[i]
  message(paste0('Working on ', this_village, '.'))
  sub_locations <- locations[locations$village == this_village,]
  houses[i] <- nrow(sub_locations)
  x <- rgeos::gConvexHull(sub_locations)
  # Project it
  y <- spTransform(x, 
                   CRS( "+init=epsg:3347" ))
  areas[i] <- rgeos::gArea(y)
  plot(x, add = T, col = adjustcolor(sample(rainbow(1000), 1), alpha.f = 0.15),
       border = adjustcolor('black', alpha.f = 0.4), lwd = 0.2)
}
```

To help elucidate potential causes for the overly large and overlapping villages (above), the below table shows each household location, its official village designation, as well as the names of those villages in whose boundaries the house's locations falls. Note: this is just a sample of the first 100 houses in the data (populating this report with all `r nrow(census)` houses would be too large); if you would like all `r nrow(census)` houses, let me know, and I'll send a "flat" file (ie, a `.csv`) with that location.

```{r}
temp <-
  locations
temp$also_in <- NA
for (i in 1:100){
  message(paste0(i, ' of ', nrow(temp)))
  sub_temp <- temp[i,]
  overs <- rep(NA, length(villages))
  for (j in 1:length(villages)){
    this_village = villages[j]
    sub_locations <- locations[locations$village == this_village,]
    if(nrow(sub_locations) > 2){
      x <- rgeos::gConvexHull(sub_locations)
      overs[j] <- over(sub_temp, polygons(x))
    }
  }
  temp$also_in[i] <- 
    paste0(villages[which(!is.na(overs))], collapse = ', ')
}

temp_df <- temp@data
temp_df <- temp_df[1:100,]
names(temp_df) <- Hmisc::capitalize(gsub('_', ' ', names(temp_df)))
DT::datatable(temp_df)
```

It may also be helpful to identify the overly large villages (ie, those with incorrect inclusions), by comparing their area. The below table shows the area of each village (in UTM degrees) order by largest.

```{r}
village_df <- data.frame(village = villages,
                         area = areas,
                         houses = houses)
village_df <- village_df %>% 
  arrange(desc(area))
names(village_df) <- Hmisc::capitalize(names(village_df))
DT::datatable(village_df)
```

What follows is a plot of each village's area, within the confines of Mopeia. These maps go in order from the "largest" village (per the raw data) to the smallest. The points show the individual houses.

These maps can be used to diagnose and correct errors. Below each map is a table containing all of the houses that are part of that neighborhood.

```{r}
for (i in 1:nrow(village_df)){
  this_village = village_df$Village[i]
  this_color <- adjustcolor(sample(rainbow(1000), 1))
  plot(mop_map, main = paste0('Neighborhood number: ', this_village))
  message(paste0('Working on ', this_village, '.'))
  sub_locations <- locations[locations$village == this_village,]
  points(sub_locations,
         col = adjustcolor(this_color, alpha.f = 0.6),
         pch = ".")
  x <- rgeos::gConvexHull(sub_locations)
  plot(x, add = T, col = adjustcolor(this_color, alpha.f = 0.1),
       border = adjustcolor('black', alpha.f = 0.4), lwd = 0.2)
  sub_locations
}
```